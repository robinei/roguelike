# Roguelike ECS Project

A simple, efficient Entity-Component-System roguelike in C99 with platform abstraction for native and web deployment.

## Project Overview

This is a turn-based roguelike built on a sparse array-based ECS. The game logic is completely platform-agnostic, using a command buffer rendering API that works identically on SDL3 (native) and WebGL (web).

## Architecture

### Core Design Principles

- **Platform abstraction** - Game logic knows nothing about SDL, WebGL, or the host platform
- **Command buffer rendering** - All rendering goes through a simple command buffer API
- **Sparse ECS** - Simple sparse arrays + bitsets instead of complex archetype systems
- **Turn-based with animation** - Actions are instant in game logic, animated for presentation
- **Hot-reload development** - Native build supports code hot-reloading via dynamic libraries

### Three-Layer Architecture

```
┌─────────────────────────────────────────┐
│   Game Logic (platform-agnostic C99)    │
│   - ECS with bitset queries             │
│   - Turn queue system                   │
│   - Action resolution                   │
│   - Particle system                     │
└─────────────────────────────────────────┘
              ↕ (PlatformContext + CommandBuffer)
┌─────────────────────────────────────────┐
│         Host Implementation             │
│  SDL3 (native)     WebGL (browser)      │
│  - Hot-reload      - WASM + JS          │
│  - Fast iteration  - Cross-platform     │
└─────────────────────────────────────────┘
```

## Rendering System

### Command Buffer API

The game emits simple rendering commands that the host executes:

```c
// Render API (src/game/render_api.h)
typedef struct {
  int viewport_width_px;
  int viewport_height_px;
  int tile_size;
  void (*execute_render_commands)(void *impl_data, const CommandBuffer *buffer);
  void *impl_data;
} PlatformContext;

// Drawing functions
cmdbuf_tile(&buf, ctx, tile_index, x, y, w, h);
cmdbuf_rect(&buf, ctx, x, y, w, h, RGBA(r, g, b, a));
cmdbuf_line(&buf, ctx, x0, y0, x1, y1, RGBA(r, g, b, a));
cmdbuf_text(&buf, ctx, x, y, TEXT_ALIGN_RIGHT, bg_color, "Score: %d", score);
```

### Batched WebGL Rendering

- **Single texture atlas** - Tiles (0-10299), font glyphs (10300-10555), white tile (10711)
- **Vertex color batching** - All rendering uses same shader, texture + vertex color modulation
- **No mode switching** - Textured quads and colored rects use identical pipeline
- **Efficient batching** - Typically 1-2 draw calls per frame

```javascript
// Textured tile: white vertex color (1,1,1,1) × texture
batchQuad(x, y, w, h, atlasX, atlasY, atlasW, atlasH);

// Colored rect: vertex color × white tile center pixel
batchRect(x, y, w, h, r, g, b, a);
```

### Combined Texture Atlas

Generated by `combine_atlases.py` during build:
- **Input**: `urizen_onebit_tileset__v2d0.png` + `cp437_12x12.png`
- **Output**: `build/combined_tileset.png` (2679×678 pixels)
- **Layout**: 12×12 tiles with 1px transparent padding
- **Last tile** (10711): Pure white for colored rect rendering

## Entity Component System

### Sparse Array Design (Parts)

The ECS uses **Parts** (components) that are defined via X-macros in [src/game/parts.h](src/game/parts.h):

```c
// Parts are just arrays indexed by entity ID
PART(Position, entity) = (Position){x, y};
PART(Health, entity) = 100;

// Bitsets track which entities have which parts
if (HAS_PART(Position, entity_idx)) { ... }

// Add/remove parts
ADD_PART(Position, entity_idx, (Position){x, y});
REMOVE_PART(Position, entity_idx);
```

### Current Parts (Components)

**Data Parts:**
- `Identity` - EntityIdentity (named entities like "Excalibur", "Grog")
- `Parent` - EntityIndex (hierarchy support)
- `TurnSchedule` - Turn queue integration
- `Goals` - GoalIndex (AI goal stack pointer)
- `Position` - uint16_t x, y
- `Material` - uint8_t (wood, iron, steel, etc.)
- `Attributes` - str/dex/wil/con (4-bit packed)
- `AttributesModifier` - Signed attribute modifiers
- `Health` - uint8_t (current health)
- `BodyPart` - type + index (head, torso, arm, etc.)
- `ParticleEmitter` - Particle system integration

**Marks (Boolean Tags):**
- `IsEquipped` - Entity is equipped by parent
- `IsInventory` - Entity is in parent's inventory
- `IsDead` - Entity has died

### Query Interface

```c
// Iterate entities with specific parts using WORLD_QUERY + BITS
WORLD_QUERY(i, BITS(Position) & BITS(Health) & ~BITS(IsDead)) {
    Position *pos = &PART(Position, i);
    uint8_t hp = PART(Health, i);
    // ... game logic
}

// Query entities in an EntitySet using ENTITYSET_QUERY + HAS
ENTITYSET_QUERY(i, &set, HAS(Position) && !HAS(IsDead)) {
    Position *pos = &PART(Position, i);
    // ... game logic
}
```

### Entity Handles and Generations

Entities use generational indices for safe references:

```c
typedef struct {
  uint32_t _generation : 16;
  uint32_t _index : 16;
} EntityHandle;

EntityIndex idx = entity_handle_to_index(handle);  // Validates generation
EntityHandle h = entity_handle_from_index(idx);    // Creates handle
```

### Benefits

- **Simple debugging** - Parts at `PART(Position, entity_idx)`, no indirection
- **Fast random access** - O(1) part lookup by entity ID
- **Cache-friendly iteration** - Contiguous arrays, no pointer chasing
- **Easy serialization** - Just save the arrays
- **Type safety** - X-macros generate bitsets and arrays automatically

## Turn System

### Turn Queue with Animation Decoupling

```c
// Turn queue orders entity actions by delay (priority queue)
EntityHandle next = turn_queue_peek();

// Actions modify game state instantly
action_move(entity, direction);  // Updates position immediately

// But set animation state for presentation
WORLD.anim.type = ACTION_ANIM_MOVE;
WORLD.anim.progress = 0.0;
WORLD.anim.move.from = old_pos;
WORLD.anim.move.to = new_pos;

// Rendering interpolates based on animation progress
float t = WORLD.anim.progress;
float render_x = from.x + (to.x - from.x) * t;
```

### Animation Types

- **Move**: Smooth interpolation between tiles
- **Attack**: Bump animation toward target
- **None**: Static rendering at logical position

## Build System

### Targets

```bash
make              # Build native SDL3 version with hot-reload
make wasm         # Build WebAssembly + generate combined atlas
make clean        # Clean all build artifacts
make run          # Run native build
python3 -m http.server 8000 --directory build/web  # Serve web build
```

### Hot-Reload (Native Only)

The SDL3 host compiles game logic as a shared library and reloads it when changed:

```c
// src/sdl3_host/main.c
typedef struct {
  void *handle;
  time_t last_write_time;
  GameAPI api;  // Function pointers to game_init, game_frame, etc.
} GameCode;

// Reload when game.so timestamp changes
if (should_reload_game_code(&game_code)) {
  reload_game_code(&game_code);
}
```

**Benefits**:
- Edit C code, see changes in ~1 second
- Game state preserved across reloads (in host, not lib)
- Faster iteration than compile-restart cycle

## File Structure

```
src/
├── game/                    # Platform-agnostic game logic
│   ├── common.h            # Core types (EntityHandle, Direction, bitsets)
│   ├── parts.h             # ECS part definitions (X-macro based)
│   ├── world.h/.c          # World state, entity management, queries
│   ├── identity.h          # Named entity identities (Excalibur, Grog, etc.)
│   ├── game.h/.c           # Main game loop, rendering, input handling
│   ├── render_api.h/.c     # Command buffer API
│   ├── turn_queue.h/.c     # Priority queue for turn-based scheduling
│   ├── particles.h/.c      # Particle system
│   ├── map.h/.c            # Map data structures
│   ├── fov.h/.c            # Field-of-view calculations
│   ├── flood.h/.c          # Flood-fill algorithms
│   ├── random.h            # PCG random number generator
│   ├── prnf.h              # Printf-style formatting (freestanding)
│   ├── actions/            # Game actions
│   │   ├── actions.h       # Action function declarations
│   │   ├── move.c          # Movement action
│   │   └── combat.c        # Combat action
│   ├── ai/                 # AI goal system
│   │   ├── ai.h/.c         # Goal stack management
│   │   └── (goal types: IDLE, MURDER, MOVE)
│   ├── events/             # Entity event handlers
│   │   ├── events.h
│   │   └── take_action_idle.c
│   └── mapgen/             # Map generation
│       ├── mapgen.h
│       └── bsp_gen.c       # BSP dungeon generator
├── sdl3_host/              # Native host with hot-reload
│   └── main.c
└── web_host/               # WebGL host
    ├── game.js             # WebGL rendering + WASM integration
    ├── index.html
    └── favicon.ico
```

## Key Systems Implemented

### AI Goal System
- **Goal stacks** - Entities with `Goals` part have a stack of goals
- **Goal types** - IDLE, MURDER, MOVE (defined in [src/game/ai/ai.h](src/game/ai/ai.h))
- **Original intent** - Goals remember the root goal that spawned them
- **Event system** - `entity_event_take_action_idle()` processes goal execution
- **Freelist allocation** - Goals are pooled in AIState for efficient management

### Combat System
- **Attributes** - STR/DEX/WIL/CON (4-bit packed)
- **Damage types** - Slash/Pierce/Blunt/Fire/Frost/Shock
- **Damage rolls** - 1d4 through 6d6 (enum-based roll types)
- **Materials** - Wood, Leather, Bronze, Iron, Steel, Mithril, Adamantine
- **Body parts** - Head, Torso, Arm, Leg, Wing, Tentacle, Tail
- **Equipment system** - `IsEquipped` mark + `Parent` hierarchy

### Entity Hierarchy
- **Parent part** - Entities can have parents (for inventory/equipment)
- **EntitySet** - Collections with fast membership test + iteration
- **Recursive operations** - `entityset_expand_descendants()`, `entityset_free()`
- **Attribute inheritance** - `get_attributes_ancestor()` walks parent chain
- **Position inheritance** - `get_position_ancestor()` for nested entities

### Camera System
- Smooth camera centered on player
- Sub-pixel camera positioning during move animations
- Viewport culling (only renders visible tiles)

### Message Log
- Circular buffer for game messages (via `output_message()`)
- Displays last 5 messages at bottom of screen
- Semi-transparent background per message

### FPS Counter
- Calculated every second (frame count / accumulated time)
- Rendered in upper right corner
- Uses text rendering utility with right alignment

### Text Rendering
- Format string support via `cmdbuf_text()`
- Left/right alignment for UI positioning
- Optional semi-transparent background
- Uses CP437 font glyphs from combined atlas

### Particle System
- Particle emitters attached to entities (`ParticleEmitter` part)
- Position inheritance (emitter follows entity)
- Tick-based spawn intervals (10Hz tick system)
- Delta-time interpolated updates

### Map Generation
- BSP dungeon generator ([src/game/mapgen/bsp_gen.c](src/game/mapgen/bsp_gen.c))
- Flood-fill utilities for connectivity analysis
- FOV (field-of-view) system using shadow casting

## Performance Characteristics

### ECS Performance
- **Component access**: O(1) - direct array lookup
- **Entity allocation**: O(1) - freelist
- **Query iteration**: O(entities_with_components) - bitset scanning
- **Memory**: ~90KB for 1000 entities × 10 components

### Rendering Performance
- **WebGL batching**: 1-2 draw calls per frame typical
- **Native rendering**: Minimal state changes, texture binding once per frame
- **Camera culling**: Only renders visible viewport tiles

## Development Workflow

### Typical Session (Native)

```bash
# Terminal 1: Watch and rebuild on changes
make run

# Terminal 2: Edit code
vim src/game/game.c

# Save file → builds automatically → reloads in game
```

### Typical Session (Web)

```bash
# Terminal 1: Build and serve
make serve

# Terminal 2: Edit code
vim src/game/game.c

# Rebuild, refresh browser
make wasm  # F5 in browser
```

## Future Platform Support

The command buffer API makes it trivial to add new platforms:

- **Raylib**: Implement `execute_render_commands()` with Raylib calls
- **Terminal**: Render to ncurses/termbox
- **Mobile**: Use platform's 2D API (Metal/Vulkan/GLES)
- **Custom engine**: Just implement the command buffer executor

All game logic stays identical across platforms.

## Why This Architecture?

### Platform Abstraction Benefits
- Write game logic once, runs everywhere
- Test/debug in fast native build with hot-reload
- Deploy to web with zero code changes
- Easy to add new platforms

### Command Buffer Benefits
- Host controls when/how rendering happens
- Trivial to record/replay for debugging
- Can batch/optimize without changing game code
- Natural separation of concerns

### ECS Benefits
- Simple mental model (just arrays)
- Easy to debug (print `PART(Position, 5)`)
- Fast iteration (no pointer chasing)
- Rapid prototyping of game mechanics
- X-macros ensure type safety and eliminate boilerplate

### Trade-offs
- **Memory**: Sparse arrays waste space for unused entities
- **Cache**: Less optimal than archetype-based ECS for very large games
- **Flexibility**: Some advanced ECS patterns harder to express

For a roguelike with <10k entities, these trade-offs are negligible while the development speed gains are substantial.

## Design Philosophy

### Data-Oriented Component Design
When designing parts (components), prefer **direct data representation** over conceptual wrappers:

**Good:**
```c
PART(Goals, EntityIndex)  // Entity has AI goals
PART(Health, uint8_t)     // Entity has health
```

**Avoid:**
```c
PART(Brain, Brain)        // What does "Brain" contain?
PART(Stats, Stats)        // Too vague, split into specific parts
```

Benefits of direct naming:
- Queries are self-documenting: `WORLD_QUERY(i, BITS(Goals))` is clear
- Future flexibility: Add `Aggression`, `Fear` without breaking naming metaphor
- No wrapper tax: Access data directly without extra indirection
- Composition over hierarchy: Mix and match parts freely

### Entity Identity System
Named entities (like "Excalibur" or "Grog") use the `Identity` part:
- Defined via X-macro in [src/game/identity.h](src/game/identity.h)
- Stores name and description strings
- Enum values for compile-time checks
- Used for unique artifacts, named NPCs, etc.
