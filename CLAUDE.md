# Roguelike ECS Project

A simple, efficient Entity-Component-System roguelike in C99 with platform abstraction for native and web deployment.

## Project Overview

This is a turn-based roguelike built on a sparse array-based ECS. The game logic is completely platform-agnostic, using a command buffer rendering API that works identically on SDL3 (native) and WebGL (web).

## Architecture

### Core Design Principles

- **Platform abstraction** - Game logic knows nothing about SDL, WebGL, or the host platform
- **Command buffer rendering** - All rendering goes through a simple command buffer API
- **Sparse ECS** - Simple sparse arrays + bitsets instead of complex archetype systems
- **Turn-based with animation** - Actions are instant in game logic, animated for presentation
- **Hot-reload development** - Native build supports code hot-reloading via dynamic libraries

### Three-Layer Architecture

```
┌─────────────────────────────────────────┐
│   Game Logic (platform-agnostic C99)    │
│   - ECS with bitset queries             │
│   - Turn queue system                   │
│   - Action resolution                   │
│   - Particle system                     │
└─────────────────────────────────────────┘
              ↕ (PlatformContext + CommandBuffer)
┌─────────────────────────────────────────┐
│         Host Implementation             │
│  SDL3 (native)     WebGL (browser)      │
│  - Hot-reload      - WASM + JS          │
│  - Fast iteration  - Cross-platform     │
└─────────────────────────────────────────┘
```

## Rendering System

### Command Buffer API

The game emits simple rendering commands that the host executes:

```c
// Render API (src/game/render_api.h)
typedef struct {
  int viewport_width_px;
  int viewport_height_px;
  int tile_size;
  void (*execute_render_commands)(void *impl_data, const CommandBuffer *buffer);
  void *impl_data;
} PlatformContext;

// Drawing functions
cmdbuf_tile(&buf, ctx, tile_index, x, y, w, h);
cmdbuf_rect(&buf, ctx, x, y, w, h, RGBA(r, g, b, a));
cmdbuf_line(&buf, ctx, x0, y0, x1, y1, RGBA(r, g, b, a));
cmdbuf_text(&buf, ctx, x, y, TEXT_ALIGN_RIGHT, bg_color, "Score: %d", score);
```

### Batched WebGL Rendering

- **Single texture atlas** - Tiles (0-10299), font glyphs (10300-10555), white tile (10711)
- **Vertex color batching** - All rendering uses same shader, texture + vertex color modulation
- **No mode switching** - Textured quads and colored rects use identical pipeline
- **Efficient batching** - Typically 1-2 draw calls per frame

```javascript
// Textured tile: white vertex color (1,1,1,1) × texture
batchQuad(x, y, w, h, atlasX, atlasY, atlasW, atlasH);

// Colored rect: vertex color × white tile center pixel
batchRect(x, y, w, h, r, g, b, a);
```

### Combined Texture Atlas

Generated by `combine_atlases.py` during build:
- **Input**: `urizen_onebit_tileset__v2d0.png` + `cp437_12x12.png`
- **Output**: `build/combined_tileset.png` (2679×678 pixels)
- **Layout**: 12×12 tiles with 1px transparent padding
- **Last tile** (10711): Pure white for colored rect rendering

## Entity Component System

### Sparse Array Design

```c
// Components are just arrays indexed by entity ID
world.position[entity_id] = (Position){x, y};
world.health[entity_id] = (Health){100, 100};

// Bitsets track which entities have which components
if (entity_has(entity_id, position)) { ... }
```

### Query Interface

```c
// Iterate entities with specific components
world_query(i, BITS(position) & BITS(health)) {
    Position *pos = &WORLD.position[i];
    Health *hp = &WORLD.health[i];
    // ... game logic
}
```

### Benefits

- **Simple debugging** - Components at `world.position[entity_id]`, no indirection
- **Fast random access** - O(1) component lookup by entity ID
- **Cache-friendly iteration** - Contiguous arrays, no pointer chasing
- **Easy serialization** - Just save the arrays

## Turn System

### Turn Queue with Animation Decoupling

```c
// Turn queue orders entity actions by delay (priority queue)
EntityHandle next = turn_queue_peek();

// Actions modify game state instantly
action_move(entity, direction);  // Updates position immediately

// But set animation state for presentation
WORLD.anim.type = ACTION_ANIM_MOVE;
WORLD.anim.progress = 0.0;
WORLD.anim.move.from = old_pos;
WORLD.anim.move.to = new_pos;

// Rendering interpolates based on animation progress
float t = WORLD.anim.progress;
float render_x = from.x + (to.x - from.x) * t;
```

### Animation Types

- **Move**: Smooth interpolation between tiles
- **Attack**: Bump animation toward target
- **None**: Static rendering at logical position

## Build System

### Targets

```bash
make              # Build native SDL3 version with hot-reload
make wasm         # Build WebAssembly + generate combined atlas
make clean        # Clean all build artifacts
make run          # Run native build
python3 -m http.server 8000 --directory build/web  # Serve web build
```

### Hot-Reload (Native Only)

The SDL3 host compiles game logic as a shared library and reloads it when changed:

```c
// src/sdl3_host/main.c
typedef struct {
  void *handle;
  time_t last_write_time;
  GameAPI api;  // Function pointers to game_init, game_frame, etc.
} GameCode;

// Reload when game.so timestamp changes
if (should_reload_game_code(&game_code)) {
  reload_game_code(&game_code);
}
```

**Benefits**:
- Edit C code, see changes in ~1 second
- Game state preserved across reloads (in host, not lib)
- Faster iteration than compile-restart cycle

## File Structure

```
src/
├── game/                    # Platform-agnostic game logic
│   ├── game.c              # Main game loop, rendering
│   ├── world.c             # ECS implementation
│   ├── actions/            # Game actions (move, attack, etc.)
│   ├── particles.c         # Particle system
│   ├── turn_queue.c        # Turn scheduling
│   └── render_api.c        # Command buffer implementation
├── sdl3_host/              # Native host with hot-reload
│   └── main.c
└── web_host/               # WebGL host
    ├── game.js             # WebGL rendering + WASM integration
    └── index.html
```

## Key Features Implemented

### Camera System
- Smooth camera centered on player
- Sub-pixel camera positioning during move animations
- Viewport culling (only renders visible tiles)

### Message Log
- Circular buffer for game messages
- Displays last 5 messages at bottom of screen
- Semi-transparent background per message

### FPS Counter
- Calculated every second (frame count / accumulated time)
- Rendered in upper right corner
- Uses text rendering utility with right alignment

### Text Rendering
- Format string support via `cmdbuf_text()`
- Left/right alignment for UI positioning
- Optional semi-transparent background
- Uses CP437 font glyphs from combined atlas

### Particle System
- Particle emitters attached to entities
- Position inheritance (emitter follows entity)
- Tick-based spawn intervals
- Delta-time interpolated updates

## Performance Characteristics

### ECS Performance
- **Component access**: O(1) - direct array lookup
- **Entity allocation**: O(1) - freelist
- **Query iteration**: O(entities_with_components) - bitset scanning
- **Memory**: ~90KB for 1000 entities × 10 components

### Rendering Performance
- **WebGL batching**: 1-2 draw calls per frame typical
- **Native rendering**: Minimal state changes, texture binding once per frame
- **Camera culling**: Only renders visible viewport tiles

## Development Workflow

### Typical Session (Native)

```bash
# Terminal 1: Watch and rebuild on changes
make run

# Terminal 2: Edit code
vim src/game/game.c

# Save file → builds automatically → reloads in game
```

### Typical Session (Web)

```bash
# Terminal 1: Build and serve
make serve

# Terminal 2: Edit code
vim src/game/game.c

# Rebuild, refresh browser
make wasm  # F5 in browser
```

## Future Platform Support

The command buffer API makes it trivial to add new platforms:

- **Raylib**: Implement `execute_render_commands()` with Raylib calls
- **Terminal**: Render to ncurses/termbox
- **Mobile**: Use platform's 2D API (Metal/Vulkan/GLES)
- **Custom engine**: Just implement the command buffer executor

All game logic stays identical across platforms.

## Why This Architecture?

### Platform Abstraction Benefits
- Write game logic once, runs everywhere
- Test/debug in fast native build with hot-reload
- Deploy to web with zero code changes
- Easy to add new platforms

### Command Buffer Benefits
- Host controls when/how rendering happens
- Trivial to record/replay for debugging
- Can batch/optimize without changing game code
- Natural separation of concerns

### ECS Benefits
- Simple mental model (just arrays)
- Easy to debug (print `world.position[5]`)
- Fast iteration (no pointer chasing)
- Rapid prototyping of game mechanics

### Trade-offs
- **Memory**: Sparse arrays waste space for unused entities
- **Cache**: Less optimal than archetype-based ECS for very large games
- **Flexibility**: Some advanced ECS patterns harder to express

For a roguelike with <10k entities, these trade-offs are negligible while the development speed gains are substantial.
